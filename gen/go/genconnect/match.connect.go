// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: Match.proto

package genconnect

import (
	context "context"
	errors "errors"
	gen "github.com/WolffunService/thetan-buf/gen"
	connect_go "github.com/bufbuild/connect-go"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// MatchServiceName is the fully-qualified name of the MatchService service.
	MatchServiceName = "core.proto.MatchService"
	// MatchHandleServiceName is the fully-qualified name of the MatchHandleService service.
	MatchHandleServiceName = "core.proto.MatchHandleService"
	// MatchDirectorServiceName is the fully-qualified name of the MatchDirectorService service.
	MatchDirectorServiceName = "core.proto.MatchDirectorService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// MatchServiceCreateMatchWithVersionProcedure is the fully-qualified name of the MatchService's
	// CreateMatchWithVersion RPC.
	MatchServiceCreateMatchWithVersionProcedure = "/core.proto.MatchService/CreateMatchWithVersion"
	// MatchServiceRegisterMatchFoundProcedure is the fully-qualified name of the MatchService's
	// RegisterMatchFound RPC.
	MatchServiceRegisterMatchFoundProcedure = "/core.proto.MatchService/RegisterMatchFound"
	// MatchServiceCancelMatchMakingProcedure is the fully-qualified name of the MatchService's
	// CancelMatchMaking RPC.
	MatchServiceCancelMatchMakingProcedure = "/core.proto.MatchService/CancelMatchMaking"
	// MatchHandleServiceHandlePlayAgainProcedure is the fully-qualified name of the
	// MatchHandleService's HandlePlayAgain RPC.
	MatchHandleServiceHandlePlayAgainProcedure = "/core.proto.MatchHandleService/HandlePlayAgain"
	// MatchHandleServiceHandleDeleteTicketProcedure is the fully-qualified name of the
	// MatchHandleService's HandleDeleteTicket RPC.
	MatchHandleServiceHandleDeleteTicketProcedure = "/core.proto.MatchHandleService/HandleDeleteTicket"
	// MatchDirectorServiceCancelTicketProcedure is the fully-qualified name of the
	// MatchDirectorService's CancelTicket RPC.
	MatchDirectorServiceCancelTicketProcedure = "/core.proto.MatchDirectorService/CancelTicket"
	// MatchDirectorServiceGetBotsProcedure is the fully-qualified name of the MatchDirectorService's
	// GetBots RPC.
	MatchDirectorServiceGetBotsProcedure = "/core.proto.MatchDirectorService/GetBots"
	// MatchDirectorServiceCreateMatchOnboardProcedure is the fully-qualified name of the
	// MatchDirectorService's CreateMatchOnboard RPC.
	MatchDirectorServiceCreateMatchOnboardProcedure = "/core.proto.MatchDirectorService/CreateMatchOnboard"
)

// MatchServiceClient is a client for the core.proto.MatchService service.
type MatchServiceClient interface {
	CreateMatchWithVersion(context.Context, *connect_go.Request[gen.MatchProtoVersionPackage]) (*connect_go.ServerStreamForClient[gen.MatchProtoPackage], error)
	// register de nhan su kien match found
	RegisterMatchFound(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.ServerStreamForClient[gen.MatchProtoPackage], error)
	CancelMatchMaking(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.MatchProtoPackage], error)
}

// NewMatchServiceClient constructs a client for the core.proto.MatchService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMatchServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MatchServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &matchServiceClient{
		createMatchWithVersion: connect_go.NewClient[gen.MatchProtoVersionPackage, gen.MatchProtoPackage](
			httpClient,
			baseURL+MatchServiceCreateMatchWithVersionProcedure,
			opts...,
		),
		registerMatchFound: connect_go.NewClient[gen.MatchProtoPackage, gen.MatchProtoPackage](
			httpClient,
			baseURL+MatchServiceRegisterMatchFoundProcedure,
			opts...,
		),
		cancelMatchMaking: connect_go.NewClient[gen.MatchProtoPackage, gen.MatchProtoPackage](
			httpClient,
			baseURL+MatchServiceCancelMatchMakingProcedure,
			opts...,
		),
	}
}

// matchServiceClient implements MatchServiceClient.
type matchServiceClient struct {
	createMatchWithVersion *connect_go.Client[gen.MatchProtoVersionPackage, gen.MatchProtoPackage]
	registerMatchFound     *connect_go.Client[gen.MatchProtoPackage, gen.MatchProtoPackage]
	cancelMatchMaking      *connect_go.Client[gen.MatchProtoPackage, gen.MatchProtoPackage]
}

// CreateMatchWithVersion calls core.proto.MatchService.CreateMatchWithVersion.
func (c *matchServiceClient) CreateMatchWithVersion(ctx context.Context, req *connect_go.Request[gen.MatchProtoVersionPackage]) (*connect_go.ServerStreamForClient[gen.MatchProtoPackage], error) {
	return c.createMatchWithVersion.CallServerStream(ctx, req)
}

// RegisterMatchFound calls core.proto.MatchService.RegisterMatchFound.
func (c *matchServiceClient) RegisterMatchFound(ctx context.Context, req *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.ServerStreamForClient[gen.MatchProtoPackage], error) {
	return c.registerMatchFound.CallServerStream(ctx, req)
}

// CancelMatchMaking calls core.proto.MatchService.CancelMatchMaking.
func (c *matchServiceClient) CancelMatchMaking(ctx context.Context, req *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.MatchProtoPackage], error) {
	return c.cancelMatchMaking.CallUnary(ctx, req)
}

// MatchServiceHandler is an implementation of the core.proto.MatchService service.
type MatchServiceHandler interface {
	CreateMatchWithVersion(context.Context, *connect_go.Request[gen.MatchProtoVersionPackage], *connect_go.ServerStream[gen.MatchProtoPackage]) error
	// register de nhan su kien match found
	RegisterMatchFound(context.Context, *connect_go.Request[gen.MatchProtoPackage], *connect_go.ServerStream[gen.MatchProtoPackage]) error
	CancelMatchMaking(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.MatchProtoPackage], error)
}

// NewMatchServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMatchServiceHandler(svc MatchServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(MatchServiceCreateMatchWithVersionProcedure, connect_go.NewServerStreamHandler(
		MatchServiceCreateMatchWithVersionProcedure,
		svc.CreateMatchWithVersion,
		opts...,
	))
	mux.Handle(MatchServiceRegisterMatchFoundProcedure, connect_go.NewServerStreamHandler(
		MatchServiceRegisterMatchFoundProcedure,
		svc.RegisterMatchFound,
		opts...,
	))
	mux.Handle(MatchServiceCancelMatchMakingProcedure, connect_go.NewUnaryHandler(
		MatchServiceCancelMatchMakingProcedure,
		svc.CancelMatchMaking,
		opts...,
	))
	return "/core.proto.MatchService/", mux
}

// UnimplementedMatchServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMatchServiceHandler struct{}

func (UnimplementedMatchServiceHandler) CreateMatchWithVersion(context.Context, *connect_go.Request[gen.MatchProtoVersionPackage], *connect_go.ServerStream[gen.MatchProtoPackage]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchService.CreateMatchWithVersion is not implemented"))
}

func (UnimplementedMatchServiceHandler) RegisterMatchFound(context.Context, *connect_go.Request[gen.MatchProtoPackage], *connect_go.ServerStream[gen.MatchProtoPackage]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchService.RegisterMatchFound is not implemented"))
}

func (UnimplementedMatchServiceHandler) CancelMatchMaking(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.MatchProtoPackage], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchService.CancelMatchMaking is not implemented"))
}

// MatchHandleServiceClient is a client for the core.proto.MatchHandleService service.
type MatchHandleServiceClient interface {
	HandlePlayAgain(context.Context, *connect_go.Request[gen.DataPlayAgainSuccess]) (*connect_go.Response[gen.EmptyResponse], error)
	HandleDeleteTicket(context.Context, *connect_go.Request[gen.DeleteTicketSuccess]) (*connect_go.Response[gen.EmptyResponse], error)
}

// NewMatchHandleServiceClient constructs a client for the core.proto.MatchHandleService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMatchHandleServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MatchHandleServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &matchHandleServiceClient{
		handlePlayAgain: connect_go.NewClient[gen.DataPlayAgainSuccess, gen.EmptyResponse](
			httpClient,
			baseURL+MatchHandleServiceHandlePlayAgainProcedure,
			opts...,
		),
		handleDeleteTicket: connect_go.NewClient[gen.DeleteTicketSuccess, gen.EmptyResponse](
			httpClient,
			baseURL+MatchHandleServiceHandleDeleteTicketProcedure,
			opts...,
		),
	}
}

// matchHandleServiceClient implements MatchHandleServiceClient.
type matchHandleServiceClient struct {
	handlePlayAgain    *connect_go.Client[gen.DataPlayAgainSuccess, gen.EmptyResponse]
	handleDeleteTicket *connect_go.Client[gen.DeleteTicketSuccess, gen.EmptyResponse]
}

// HandlePlayAgain calls core.proto.MatchHandleService.HandlePlayAgain.
func (c *matchHandleServiceClient) HandlePlayAgain(ctx context.Context, req *connect_go.Request[gen.DataPlayAgainSuccess]) (*connect_go.Response[gen.EmptyResponse], error) {
	return c.handlePlayAgain.CallUnary(ctx, req)
}

// HandleDeleteTicket calls core.proto.MatchHandleService.HandleDeleteTicket.
func (c *matchHandleServiceClient) HandleDeleteTicket(ctx context.Context, req *connect_go.Request[gen.DeleteTicketSuccess]) (*connect_go.Response[gen.EmptyResponse], error) {
	return c.handleDeleteTicket.CallUnary(ctx, req)
}

// MatchHandleServiceHandler is an implementation of the core.proto.MatchHandleService service.
type MatchHandleServiceHandler interface {
	HandlePlayAgain(context.Context, *connect_go.Request[gen.DataPlayAgainSuccess]) (*connect_go.Response[gen.EmptyResponse], error)
	HandleDeleteTicket(context.Context, *connect_go.Request[gen.DeleteTicketSuccess]) (*connect_go.Response[gen.EmptyResponse], error)
}

// NewMatchHandleServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMatchHandleServiceHandler(svc MatchHandleServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(MatchHandleServiceHandlePlayAgainProcedure, connect_go.NewUnaryHandler(
		MatchHandleServiceHandlePlayAgainProcedure,
		svc.HandlePlayAgain,
		opts...,
	))
	mux.Handle(MatchHandleServiceHandleDeleteTicketProcedure, connect_go.NewUnaryHandler(
		MatchHandleServiceHandleDeleteTicketProcedure,
		svc.HandleDeleteTicket,
		opts...,
	))
	return "/core.proto.MatchHandleService/", mux
}

// UnimplementedMatchHandleServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMatchHandleServiceHandler struct{}

func (UnimplementedMatchHandleServiceHandler) HandlePlayAgain(context.Context, *connect_go.Request[gen.DataPlayAgainSuccess]) (*connect_go.Response[gen.EmptyResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchHandleService.HandlePlayAgain is not implemented"))
}

func (UnimplementedMatchHandleServiceHandler) HandleDeleteTicket(context.Context, *connect_go.Request[gen.DeleteTicketSuccess]) (*connect_go.Response[gen.EmptyResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchHandleService.HandleDeleteTicket is not implemented"))
}

// MatchDirectorServiceClient is a client for the core.proto.MatchDirectorService service.
type MatchDirectorServiceClient interface {
	CancelTicket(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.EmptyResponse], error)
	GetBots(context.Context, *connect_go.Request[gen.GetBotsRequest]) (*connect_go.Response[gen.BotsResponse], error)
	CreateMatchOnboard(context.Context, *connect_go.Request[gen.CreateMatchOnboardRequest]) (*connect_go.Response[gen.MatchFoundResponseProto], error)
}

// NewMatchDirectorServiceClient constructs a client for the core.proto.MatchDirectorService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMatchDirectorServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MatchDirectorServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &matchDirectorServiceClient{
		cancelTicket: connect_go.NewClient[gen.MatchProtoPackage, gen.EmptyResponse](
			httpClient,
			baseURL+MatchDirectorServiceCancelTicketProcedure,
			opts...,
		),
		getBots: connect_go.NewClient[gen.GetBotsRequest, gen.BotsResponse](
			httpClient,
			baseURL+MatchDirectorServiceGetBotsProcedure,
			opts...,
		),
		createMatchOnboard: connect_go.NewClient[gen.CreateMatchOnboardRequest, gen.MatchFoundResponseProto](
			httpClient,
			baseURL+MatchDirectorServiceCreateMatchOnboardProcedure,
			opts...,
		),
	}
}

// matchDirectorServiceClient implements MatchDirectorServiceClient.
type matchDirectorServiceClient struct {
	cancelTicket       *connect_go.Client[gen.MatchProtoPackage, gen.EmptyResponse]
	getBots            *connect_go.Client[gen.GetBotsRequest, gen.BotsResponse]
	createMatchOnboard *connect_go.Client[gen.CreateMatchOnboardRequest, gen.MatchFoundResponseProto]
}

// CancelTicket calls core.proto.MatchDirectorService.CancelTicket.
func (c *matchDirectorServiceClient) CancelTicket(ctx context.Context, req *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.EmptyResponse], error) {
	return c.cancelTicket.CallUnary(ctx, req)
}

// GetBots calls core.proto.MatchDirectorService.GetBots.
func (c *matchDirectorServiceClient) GetBots(ctx context.Context, req *connect_go.Request[gen.GetBotsRequest]) (*connect_go.Response[gen.BotsResponse], error) {
	return c.getBots.CallUnary(ctx, req)
}

// CreateMatchOnboard calls core.proto.MatchDirectorService.CreateMatchOnboard.
func (c *matchDirectorServiceClient) CreateMatchOnboard(ctx context.Context, req *connect_go.Request[gen.CreateMatchOnboardRequest]) (*connect_go.Response[gen.MatchFoundResponseProto], error) {
	return c.createMatchOnboard.CallUnary(ctx, req)
}

// MatchDirectorServiceHandler is an implementation of the core.proto.MatchDirectorService service.
type MatchDirectorServiceHandler interface {
	CancelTicket(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.EmptyResponse], error)
	GetBots(context.Context, *connect_go.Request[gen.GetBotsRequest]) (*connect_go.Response[gen.BotsResponse], error)
	CreateMatchOnboard(context.Context, *connect_go.Request[gen.CreateMatchOnboardRequest]) (*connect_go.Response[gen.MatchFoundResponseProto], error)
}

// NewMatchDirectorServiceHandler builds an HTTP handler from the service implementation. It returns
// the path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMatchDirectorServiceHandler(svc MatchDirectorServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle(MatchDirectorServiceCancelTicketProcedure, connect_go.NewUnaryHandler(
		MatchDirectorServiceCancelTicketProcedure,
		svc.CancelTicket,
		opts...,
	))
	mux.Handle(MatchDirectorServiceGetBotsProcedure, connect_go.NewUnaryHandler(
		MatchDirectorServiceGetBotsProcedure,
		svc.GetBots,
		opts...,
	))
	mux.Handle(MatchDirectorServiceCreateMatchOnboardProcedure, connect_go.NewUnaryHandler(
		MatchDirectorServiceCreateMatchOnboardProcedure,
		svc.CreateMatchOnboard,
		opts...,
	))
	return "/core.proto.MatchDirectorService/", mux
}

// UnimplementedMatchDirectorServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMatchDirectorServiceHandler struct{}

func (UnimplementedMatchDirectorServiceHandler) CancelTicket(context.Context, *connect_go.Request[gen.MatchProtoPackage]) (*connect_go.Response[gen.EmptyResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchDirectorService.CancelTicket is not implemented"))
}

func (UnimplementedMatchDirectorServiceHandler) GetBots(context.Context, *connect_go.Request[gen.GetBotsRequest]) (*connect_go.Response[gen.BotsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchDirectorService.GetBots is not implemented"))
}

func (UnimplementedMatchDirectorServiceHandler) CreateMatchOnboard(context.Context, *connect_go.Request[gen.CreateMatchOnboardRequest]) (*connect_go.Response[gen.MatchFoundResponseProto], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("core.proto.MatchDirectorService.CreateMatchOnboard is not implemented"))
}
